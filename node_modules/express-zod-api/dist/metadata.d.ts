import { z } from "./index";
export declare const metaProp = "expressZodApiMeta";
declare type MetaProp = typeof metaProp;
export declare type MetaDef<T extends z.ZodTypeAny> = {
    [K in MetaProp]: {
        examples: z.input<T>[];
    };
};
declare type MetaKey = keyof MetaDef<any>[MetaProp];
declare type MetaValue<T extends z.ZodTypeAny, K extends MetaKey> = Readonly<MetaDef<T>[MetaProp][K]>;
declare type ExampleSetter<T extends z.ZodTypeAny> = (example: z.input<T>) => WithMeta<T>;
/**
 * @desc fixes the incompatibility of the ZodObject.keyof() method introduced in v3.17.9
 * @todo remove it if/when it will be compatible
 */
declare type MetaFixForStrippedObject<T> = T extends z.ZodObject<any> ? T & {
    keyof: z.ZodObject<any>["keyof"];
} : T;
declare type WithMeta<T extends z.ZodTypeAny> = MetaFixForStrippedObject<T> & {
    _def: T["_def"] & MetaDef<T>;
    example: ExampleSetter<T>;
};
export declare const withMeta: <T extends z.ZodTypeAny>(schema: T) => WithMeta<T>;
export declare const hasMeta: <T extends z.ZodTypeAny>(schema: T) => schema is WithMeta<T>;
export declare function getMeta<T extends z.ZodTypeAny, K extends MetaKey>(schema: T, meta: K): MetaValue<T, K> | undefined;
export declare const copyMeta: <A extends z.ZodTypeAny, B extends z.ZodTypeAny>(src: A, dest: B) => B | WithMeta<B>;
export {};
